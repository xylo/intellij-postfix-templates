
## number conversions ##

.toBoolean : convert to boolean
    java.lang.String         →  Boolean.parseBoolean($expr$)$END$

.toByte : convert to byte
    java.lang.String         →  Byte.parseByte($expr$)$END$
    NUMBER                   →  ((byte) ($expr$))$END$

.toChar : convert to char
    java.lang.String         →  $expr$.charAt(0)$END$
    NUMBER                   →  ((char) ($expr$))$END$

.toInt : convert to int
    java.lang.String         →  Integer.parseInt($expr$)$END$
    NUMBER                   →  ((int) ($expr$))$END$

.toLong : convert to long
    java.lang.String         →  Long.parseLong($expr$)$END$
    NUMBER                   →  ((long) ($expr$))$END$

.toFloat : convert to float
    java.lang.String         →  Float.parseFloat($expr$)$END$
    NUMBER                   →  ((float) ($expr$))$END$

.toDouble : convert to double
    java.lang.String         →  Double.parseDouble($expr$)$END$
    NUMBER                   →  ((double) ($expr$))$END$



## collection conversions ##

.toList : convert to List
    java.util.Collection     →  new java.util.ArrayList<>($expr$)$END$
    ARRAY                    →  java.util.Arrays.asList($expr$)$END$

.toSet : convert to Set
    java.util.Collection     →  new java.util.HashSet<>($expr$)$END$
    ARRAY                    →  new java.util.HashSet<>(java.util.Arrays.asList($expr$))$END$

.toMap : convert to Map
    java.util.Collection     →  $expr$.stream().collect(java.util.stream.Collectors.toMap($END$))
    ARRAY                    →  java.util.Arrays.stream($expr$).collect(java.util.stream.Collectors.toMap($END$))
    java.util.stream.Stream  →  $expr$.collect(java.util.stream.Collectors.toMap($END$))



## collection operations ##

.sort : sort naturally
    ARRAY                    →  java.util.Arrays.sort($expr$)$END$

.sortBy :  sort by attribute
    ARRAY                    →  java.util.Arrays.sort($expr$, java.util.Comparator.comparing($END$))
    java.util.List           →  $expr$.sort(java.util.Comparator.comparing($END$))
    java.util.stream.Stream  →  $expr$.sorted(java.util.Comparator.comparing($END$))

.minBy : minimum by attribute
    ARRAY                    →  java.util.Arrays.stream($expr$).min(java.util.Comparator.comparing($END$))
    java.util.Collection     →  $expr$.stream().min(java.util.Comparator.comparing($END$))
    java.util.stream.Stream  →  $expr$.min(java.util.Comparator.comparing($END$))

.maxBy : maximum by attribute
    ARRAY                    →  java.util.Arrays.stream($expr$).max(java.util.Comparator.comparing($END$))
    java.util.Collection     →  $expr$.stream().max(java.util.Comparator.comparing($END$))
    java.util.stream.Stream  →  $expr$.max(java.util.Comparator.comparing($END$))

.groupBy : group by attribute
    java.util.Collection     →  $expr$.stream().collect(java.util.stream.Collectors.groupingBy($END$))
    java.util.stream.Stream  →  $expr$.collect(java.util.stream.Collectors.groupingBy($END$))

.exists : any match
    java.util.Collection     →  $expr$.stream().anyMatch($END$)
    java.util.stream.Stream  →  $expr$.anyMatch($END$)

.forall : all match
    java.util.Collection     →  $expr$.stream().allMatch($END$)
    java.util.stream.Stream  →  $expr$.allMatch($END$)

.reverse : reverse collection
    java.util.List           →  java.util.Collections.reverse($expr$)$END$

.concat : concat
    ARRAY                    →  java.util.stream.Stream.concat(java.util.Arrays.stream($expr$), $END$)
    java.util.stream.Stream  →  java.util.stream.Stream.concat($expr$, $END$)

.forEach : for each
    java.util.Optional       →  $expr$.ifPresent($END$)



## others ##

.r : compile pattern
    java.lang.String         →  java.util.regex.Pattern.compile($expr$)$END$

